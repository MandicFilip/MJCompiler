package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal EOF, error;
terminal PROGRAM, CLASS, INTERFACE, EXTENDS, NEW, ENUM, RETURN;
terminal PRINT, READ, CONST, VOID, IF, ELSE, FOR, BREAK, CONTINUE;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, UNEQUAL, GREATER;
terminal GREATER_EQUAL, SMALLER, SMALLER_EQUAL, AND, OR, ASSIGNMENT;
terminal INC, DEC, SEMI, COMMA, DOT, LBRACE, RBRACE, LSQBRACE;
terminal RSQBRACE, LPAREN, RPAREN;
terminal String IDENT;
terminal String CHARCONST;
terminal Integer NUMBER;
terminal Boolean BOOL_CONST;

nonterminal Program, AllDeclList, DeclType, Type, ConstDeclExpression, ConstDeclList, ConstDecl, ConstKind;
nonterminal VarDeclExpression, VarsList, VarDecl, ArrOpt, ClassDecl, ExtendsSpec, ImplementsSpec, InterfacesList;
nonterminal OptVar, OptMethods, EnumDecl, EnumList, EnumMember, EnumInit, InterfaceDecl, InterfaceMethodList;
nonterminal InterfaceMethodDecl, RetType, FormParms, FormPara, MethodDeclList, MethodDecl;
nonterminal StatementList, Statement, OptElsePart, OptDesignatorStatement, OptCondition, OptMoreToPrint;
nonterminal DesignatorStatement, OptDesignatorStatementExtension, Condition, OptCondTermList;
nonterminal CondTerm, OptCondFactList, CondFact, OptRelOpExprList, Expr, OptAddOpTerm, Term, OptMulOpFactor, Factor;
nonterminal ActualPars, ActualParamList, Designator, OptDesignatorPart, FieldOption, ArrayOption;
nonterminal AssignOP, RelOp, Addop, MulOp;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList;

Program ::= (Program) PROGRAM IDENT:pName AllDeclList LBRACE MethodDeclList RBRACE;

AllDeclList ::= (ALLDeclarationsList) ALLDeclList DeclType
              | (NoDeclaration)
              ;

DeclType ::= (ConstDeclaration) ConstDeclExpression
           | (VarDeclaration) VarDeclExpression
           | (ClassDeclaration) ClassDecl
           | (EnumDeclaration) EnumDecl
           | (InterfaceDeclaration) InterfaceDecl
           ;


Type ::= (Type) IDENT:tName;


ConstDeclExpression ::= (ConstDeclarationExpression) CONST Type:constType ConstDeclList SEMI;

ConstDeclList ::= (ConstDeclarationList) ConstDeclList COMMA ConstDecl
                  |
                  (SingleConstDeclaration) ConstDecl
                  ;

ConstDecl ::= (ConstDeclaration) IDENT:constName ASSIGNMENT ConstKind:constValue;

ConstKind = (ConstNumber) NUMBER:numValue
            |
            (ConstChar) CHARCONST:charValue
            |
            (ConstBool) BOOL_CONST:boolValue
            ;


VarDeclExpression ::= (VarDeclarationExpression) Type:varType VarsList SEMI;

VarsList ::= (VarsList) VarsList COMMA VarDecl
             |
             (SingleVarDeclaration) VarDecl;

VarDecl ::= (VarDeclaration) IDENT:varName ArrOpt;

ArrOpt ::= (ArrayOption) LSBRACE RSBRACE
            |
            (NoArrayOption);


ClassDecl ::= (ClassDeclaration) CLASS IDENT:className ExtendsClause ImplementsClause LBRACE OptVar OptMethods  RBRACE;

ExtendsClause ::= (ExpendsClause) EXTENDS Type:className
                | (NoExpendsClause)
                ;

ImplementsClause ::= (ImplementsClause) IMPLEMENTS InterfaceList
                   | (NoImplementsClause)
                   ;

InterfaceList ::= (InterfaceList) InterfacesList COMMA Type:interfaceName
                 | (SingleInterface) Type:interfaceName
                 ;

OptVar ::= (OptionalVars) VarDeclExpression
           | (NoOptionalVars)
           ;

OptMethods ::= (OptionalMethods) MethodDeclList
               | (NoOptionalMethods)
               ;


EnumDecl ::= (EnumDeclaration) ENUM IDENT:eName LBRACE EnumList RBRACE;

EnumList ::= (EnumList) EnumList COMMA EnumMember
            | (SingleEnumMember) EnumMember
            ;

EnumMember ::= (EnumMember) IDENT:enumMemberName EnumInit;

EnumInit ::= (EnumInit) ASSIGNMENT NUMBER:enumMemberValue;

InterfaceDecl ::= (InterfaceDeclaration) INTERFACE IDENT:interfaceName LBRACE InterfaceMethodList RBRACE;

InterfaceMethodList ::= (InterfaceMethodList) InterfaceMethodList InterfaceMethodDecl
                        | (NoInterfaceMethods)
                        ;

InterfaceMethodDecl ::= (InterfaceMethodDeclaration) RetType IDENT:interfaceMetodName LPAREN FormParms RPAREN SEMI;

RetType ::= (RetType) VOID:retVoid | Type:retType;

FormParms ::= (FormParmsDeclaration) FormParams COMMA FormPara
              | FormPara (SingleFormParametarDeclaration)
              | (NoFormParmsDeclaration)
              ;

FormPara ::= Type:paramType IDENT:paramName ArrOpt;

MethodDeclList ::= (MethodDeclarationList) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDecl) RetType IDENT:methodName LPAREN FormParms RPAREN OptVar LBRACE Statement RBRACE;

////////////////////////////////

StatementList ::= (StatementList) StatementList Statement
                    |
                  (NoStatementList)
                    ;

Statement ::= (DesignatorStatement) DesignatorStatement SEMI
			  |
			  (IfStatement) IF LPAREN Condition RPAREN Statement OptElsePart
			  |
			  (ForStatement) FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI OptDesignatorStatement RPAREN Statement
			  |
			  (BreakStatement) BREAK SEMI
			  |
			  (ContinueStatement) CONTINUE SEMI
			  |
			  (ReadStatement) READ LPAREN Designator:dest RPAREN SEMI
			  |
			  (PrintStatement) PRINT LPAREN Expr:exprToPrint OptMoreToPrint RPAREN SEMI
			  |
			  (ReturnExpStatement) RETURN Expr:retExp SEMI
			  |
			  (ReturnNopStatement) RETURN SEMI
			  |
			  (StatementBlock) LBRACE Statement RBRACE
			  ;

OptElsePart ::= (ElseOption) ELSE Statement
                |
                (NoElseOption)
                ;

OptDesignatorStatement ::= (DesignatorStatement) DesignatorStatement
                           |
                           (NoDesignatorStatement)
                           ;

OptCondition::= (Condition) Condition
                |
                (NoCondition)
                ;

OptMoreToPrint ::= (PrintExtensionList) OptMoreToPrint COMMA NUMBER:value
                   |
                   (SinglePrintExtension) COMMA NUMBER:value
                   |
                   (NoPrintExtension)
                   ;

//
DesignatorStatement ::= (DesignatorStatement) Designator:dest OptDesignatorStatementExtension;

OptDesignatorStatementExtension ::= (AssignExtension) AssignOP Expr:expValue
                                    |
                                    (ParametarsExtension) LPAREN ActualPars RPAREN
                                    |
                                    (IncExtension) INC
                                    |
                                    (DecExtension) DEC
                                    |
                                    (NoExtension)
                                    ;

Condition ::= (Condition) CondTerm OptCondTermList;

OptCondTermList ::= (ConditionList) OptCondTermList OR CondTerm
                    |
                    (OrSingleCondition) OR CondTerm
                    |
                    (NoConditionList)
                    ;

CondTerm ::= (ConditionTerm) CondFact OptCondFactList;

OptCondFactList ::= (ConditionFactorList) OptCondFactList AND CondFact
                    |
                    (AndConditionFactor) AND CondFact
                    |
                    (NoConditionFactor)
                    ;

CondFact ::= (ConditionFactor) Expr OptRelOpExprList;

OptRelOpExprList ::= (RelOpWithExprList) OptRelOpExprList RelOp Expr
                     |
                     (SingleRelOpWithExpr) RelOp Expr
                     |
                     (NoRelOpWithExpr)
                     ;

Expr ::= (ExprWithUnMinus) MINUS Term OptAddOpTerm
		 |
		 (ExprWithoutMinus) Term OptAddOpTerm
		 ;

OptAddOpTerm ::= (OptionalAddOpTermList) OptAddOpTerm Addop Term
                 |
                 (SingleOptionalAddOpTerm) Addop Term
                 |
                 ;

Term ::= (Term) Factor OptMulOpFactor;

OptMulOpFactor ::= (TermWithOptionalMulOpList) OptMulOpFactor MulOp Factor
                   |
                   (SingleTermWithOptionalMulOp) MulOp Factor
                   |
                   ;

Factor ::= (NumberFactor) NUMBER:valueNumber
		   |
		   (CharFactor) CHARCONST:valueChar
		   |
		   (BoolFactor) BOOL_CONST:valBool
		   |
		   (NewTypeFactor) NEW Type ArrayOption
		   |
		   (DesignatorFactor) Designator:d
		   |
		   (FunCallFactor) Designator:func LPAREN ActualPars RPAREN
		   |
		   (ParenFactor) LPAREN Expr RPAREN
		   ;

ActualPars ::= (ActualParametarsList) ActualParamList
			   |
			   (NoActualParametarsList)
			   ;

ActualParamList ::= (ParametarsList) ActualParamList COMMA Expr
					 |
					 (SingleExpr) Expr
					 ;

Designator ::= (Designator) IDENT:dest OptDesignatorPart;

OptDesignatorPart ::= (OptionalFieldDesignatorPart) FieldOption
                    | (OptionalArrayDesignatorPart) ArrayOption
                    | (NoOptionalPart)
                    ;

FieldOption ::= (Field) DOT IDENT:desField;

ArrayOption ::= (Array) LSBRACE Expr:arrExp RSBRACE;

AssignOP ::= (Assignment) ASSIGNMENT;

RelOp ::= (Equal) EQUAL
        | (Unequal) UNEQUAL
        | (Greater) GREATER
        | (GreaterEqual) GREATER_EQUAL
        | (Smaller)SMALLER
        | (SmallerEqual) SMALLER_EQUAL;

Addop ::= (PlusOp) PLUS | (MinusOp) MINUS;

MulOp ::= (MulOp) MUL | (DivOp) DIV | (ModOp) MOD;
