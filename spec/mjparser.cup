package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal EOF, error;
terminal PROGRAM, CLASS, INTERFACE, EXTENDS, NEW, ENUM, RETURN;
terminal PRINT, READ, CONST, VOID, IF, ELSE, FOR, BREAK, CONTINUE;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, UNEQUAL, GREATER;
terminal GREATER_EQUAL, SMALLER, SMALLER_EQUAL, AND, OR, ASSIGNMENT;
terminal INC, DEC, SEMI, COMMA, DOT, LBRACE, RBRACE, LSQBRACE;
terminal RSQBRACE, LPAREN, RPAREN, TRUE, FALSE, IDENT, NUMBER, CHARCONST;


nonterminal Program, AllDeclList, DeclType, Type, ConstDeclExpression, ConstDeclList, ConstDecl, ConstKind;
nonterminal VarDeclExpression, VarsList, VarDecl, ArrOpt, ClassDecl, ExtendsSpec, ImplementsSpec, InterfacesList;
nonterminal OptVar, OptMethods, EnumDecl, EnumList, EnumMember, EnumInit, InterfaceDecl, InterfaceMethodList;
nonterminal InterfaceMethodDecl, RetType, FormParms, FormPara, MethodDeclList, MethodDecl;
nonterminal Statement, OptElsePart, OptDesignatorStatement, OptCondition, OptMoreToPrint;
nonterminal DesignatorStatement, OptDesignatorStatementExtension, Condition, OptCondTermList;
nonterminal CondTerm, OptCondFactList, CondFact, OptRelOpExprList, Expr, OptAddOpTerm, Term, OptMulOpFactor, Factor;
nonterminal ActualPars, ActualParamList, Designator, OptDesignatorPart, FieldOption, ArrayOption
nonterminal AssignOP, RelOp, Addop, MulOp

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList;

Program ::= (Program) PROGRAM IDENT:pName AllDeclList LBRACE MethodDeclList RBRACE;

AllDeclList ::= (ALLDeclarationsList) ALLDeclList DeclType
              | (NoDeclaration)
              ;

DeclType ::= (ConstDeclaration) ConstDeclExpression
           | (VarDeclaration) VarDeclExpression
           | (ClassDeclaration) ClassDecl
           | (EnumDeclaration) EnumDecl
           | (InterfaceDeclaration) InterfaceDecl
           ;


Type ::= IDENT;


ConstDeclExpression ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::= ConstDeclList COMMA ConstDecl
                  |
                  ConstDecl
                  ;

ConstDecl ::= IDENT:constName ASSIGNMENT ConstKind;

ConstKind = NUMBER
            |
            CHARCONST
            |
            TRUE
            |
            FALSE
            ;


VarDeclExpression ::= Type VarsList SEMI;

VarsList ::= VarsList COMMA VarDecl
             |
             VarDecl;

VarDecl ::= IDENT ArrOpt;

ArrOpt ::= LSBRACE RSBRACE;


ClassDecl ::= CLASS IDENT ExtendsSpec ImplementsSpec LBRACE OptVar OptMethods  RBRACE;

ExtendsSpec ::= EXTENDS Type
                |
                ;

ImplementsSpec ::= IMPLEMENTS InterfacesList
                   |
                   ;

InterfacesList ::= InterfacesList COMMA Type
                 | Type
                 ;

OptVar ::= VarDeclExpression
           |
           ;

OptMethods ::= MethodDeclList
               |
               ;


EnumDecl ::= ENUM IDENT:eName LBRACE EnumList RBRACE;

EnumList ::= EnumList COMMA EnumMember
            | EnumMember
            ;

EnumMember ::= IDENT EnumInit;

EnumInit ::= ASSIGNMENT NUMBER;

InterfaceDecl ::= INTERFACE IDENT LBRACE InterfaceMethodList RBRACE;

InterfaceMethodList ::= InterfaceMethodList InterfaceMethodDecl
                        |
                        ;

InterfaceMethodDecl ::= RetType IDENT LPAREN FormParms RPAREN SEMI;

RetType ::= VOID | Type;

FormParms ::= FormParams COMMA FormPara
              | FormPara
              |
              ;

FormPara ::= Type IDENT ArrOpt;

////////////////////////////////
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDecl) RetType IDENT LPAREN FormParms RPAREN OptVar LBRACE Statement RBRACE;


Statement ::= DesignatorStatement SEMI
			  |
			  IF LPAREN Condition RPAREN Statement OptElsePart
			  |
			  FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI OptDesignatorStatement RPAREN Statement
			  |
			  BREAK SEMI
			  |
			  CONTINUE SEMI
			  |
			  READ LPAREN Designator RPAREN SEMI
			  |
			  PRINT LPAREN Expr OptMoreToPrint RPAREN SEMI
			  |
			  RETURN Expr SEMI
			  |
			  RETURN SEMI
			  |
			  LBRACE Statement RBRACE
			  ;

OptElsePart ::= ELSE Statement
                |
                ;

OptDesignatorStatement ::= DesignatorStatement
                           |
                           ;

OptCondition::= Condition
                |
                ;

OptMoreToPrint ::= OptMoreToPrint COMMA NUMBER
                   |
                   COMMA NUMBER
                   |
                   ;

//
DesignatorStatement ::= Designator OptDesignatorStatementExtension;

OptDesignatorStatementExtension ::= AssignOP Expr
                                    |
                                    LPAREN ActualPars RPAREN
                                    |
                                    INC
                                    |
                                    DEC
                                    |
                                    ;

Condition ::= CondTerm OptCondTermList;

OptCondTermList ::= OptCondTermList OR CondTerm
                    |
                    OR CondTerm
                    |
                    ;

CondTerm ::= CondFact OptCondFactList;

OptCondFactList ::= OptCondFactList AND CondFact
                    |
                    AND CondFact
                    |
                    ;

CondFact ::= Expr OptRelOpExprList;

OptRelOpExprList ::= OptRelOpExprList RelOp Expr
                     |
                     RelOp Expr
                     |
                     ;

Expr ::= MINUS Term OptAddOpTerm
		 |
		 Term OptAddOpTerm
		 ;

OptAddOpTerm ::= OptAddOpTerm Addop Term
                 |
                 Addop Term
                 |
                 ;

Term ::= Factor OptMulOpFactor;

OptMulOpFactor ::= OptMulOpFactor MulOp Factor
                   |
                   MulOp Factor
                   |
                   ;

Factor ::= NUMBER
		   |
		   CHARCONST
		   |
		   TRUE
		   |
		   FALSE
		   |
		   NEW Type ArrayOption
		   |
		   Designator:d
		   |
		   Designator:func LPAREN ActualPars RPAREN
		   |
		   LPAREN Expr RPAREN
		   ;

ActualPars ::= ActualParamList
			   |
			   ;
			   
ActualParamList ::= ActualParamList COMMA Expr
					 |
					Expr
					;

Designator ::= IDENT OptDesignatorPart;

OptDesignatorPart ::= FieldOption
                    | ArrayOption
                    |
                    ;

FieldOption ::= DOT IDENT;

ArrayOption ::= LSBRACE Expr RSBRACE;

AssignOP ::= ASSIGNMENT;

RelOp ::= EQUAL | UNEQUAL | GREATER | GREATER_EQUAL | SMALLER | SMALLER_EQUAL;

Addop ::= PLUS | MINUS;

MulOp ::= MUL | DIV | MOD;
