package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, NEW, ENUM, RETURN;
terminal PRINT, READ, CONST, VOID, IF, ELSE, FOR, BREAK, CONTINUE;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, UNEQUAL, GREATER;
terminal GREATER_EQUAL, SMALLER, SMALLER_EQUAL, AND, OR, ASSIGNMENT;
terminal INC, DEC, SEMI, COMMA, DOT, LBRACE, RBRACE, LSQBRACE;
terminal RSQBRACE, LPAREN, RPAREN;
terminal String IDENT;
terminal Character CHARCONST;
terminal Integer NUMBER;
terminal Boolean BOOL_CONST;

nonterminal AllDeclList AllDeclList;
nonterminal DeclType DeclType;
nonterminal ConstDeclExpression ConstDeclExpression;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal ConstKind ConstKind;
nonterminal VarDeclExpression VarDeclExpression;
nonterminal VarsList VarsList;
nonterminal VarDecl VarDecl;
nonterminal Variables Variables;
nonterminal LastVarDecl LastVarDecl;
nonterminal MiddleVarDecl MiddleVarDecl;
nonterminal OptVar OptVar;
nonterminal ArrOpt ArrOpt;
nonterminal ArrWithExpr ArrWithExpr;
nonterminal EnumDecl EnumDecl;
nonterminal EnumList EnumList;
nonterminal EnumMember EnumMember;
nonterminal EnumInit EnumInit;
nonterminal RetType RetType;
nonterminal FormParams FormParams;
nonterminal FormPara FormPara;
nonterminal MethodDeclList MethodDeclList;
nonterminal Statements Statements;
nonterminal Statement Statement;
nonterminal OptDesignatorStatement OptDesignatorStatement;
nonterminal OptCondition OptCondition;
nonterminal ExpressionToPrint ExpressionToPrint;
nonterminal DesignatorStmt DesignatorStmt;
nonterminal OptDesignatorStatementExtension OptDesignatorStatementExtension;
nonterminal ConditionDecl ConditionDecl;
nonterminal IfConditionForm IfConditionForm;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal SignTerm SignTerm;
nonterminal ActualPars ActualPars;
nonterminal ActualParamList ActualParamList;
nonterminal OptDesignatorPart OptDesignatorPart;
nonterminal FieldOption FieldOption;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
nonterminal Addop Addop;
nonterminal MulOp MulOp;

nonterminal Program Program;
nonterminal Designator Designator;
nonterminal MethodDecl MethodDecl;
nonterminal Type Type;
nonterminal Term Term;
nonterminal Expr Expr;
nonterminal Factor Factor;

precedence left ELSE;

Program ::= (Program) PROGRAM IDENT:pName AllDeclList:A1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(pName, A1, M2); RESULT.setLine(pNameleft); :};

AllDeclList ::= (ALLDeclarationsList) AllDeclList:A1 DeclType:D2 {: RESULT=new ALLDeclarationsList(A1, D2); RESULT.setLine(A1left); :}
              | (NoDeclaration) {: RESULT=new NoDeclaration(); :}
              ;

DeclType ::= (ConstTypeDeclaration) ConstDeclExpression:C1 {: RESULT=new ConstTypeDeclaration(C1); RESULT.setLine(C1left); :}
           | (VarTypeDeclaration) VarDeclExpression:V1 {: RESULT=new VarTypeDeclaration(V1); RESULT.setLine(V1left); :}
           | (EnumTypeDeclaration) EnumDecl:E1 {: RESULT=new EnumTypeDeclaration(E1); RESULT.setLine(E1left); :}
           ;


Type ::= (Type) IDENT:tName {: RESULT=new Type(tName); RESULT.setLine(tNameleft); :};


ConstDeclExpression ::= (ConstDeclarationExpression) CONST Type:constType ConstDeclList:C1 SEMI {: RESULT=new ConstDeclarationExpression(constType, C1); RESULT.setLine(constTypeleft); :};

ConstDeclList ::= (ConstDeclarationList) ConstDeclList:C1 COMMA ConstDecl:C2 {: RESULT=new ConstDeclarationList(C1, C2); RESULT.setLine(C1left); :}
                  |
                  (SingleConstDeclaration) ConstDecl:C1 {: RESULT=new SingleConstDeclaration(C1); RESULT.setLine(C1left); :}
                  ;

ConstDecl ::= (ConstDeclaration) IDENT:constName ASSIGNMENT ConstKind:constValue {: RESULT=new ConstDeclaration(constName, constValue); RESULT.setLine(constNameleft); :};

ConstKind ::= (ConstNumber) NUMBER:numValue {: RESULT=new ConstNumber(numValue); RESULT.setLine(numValueleft); :}
            |
            (ConstChar) CHARCONST:charValue {: RESULT=new ConstChar(charValue); RESULT.setLine(charValueleft); :}
            |
            (ConstBool) BOOL_CONST:boolValue {: RESULT=new ConstBool(boolValue); RESULT.setLine(boolValueleft); :}
            ;

VarDeclExpression ::= (VarDeclarationExpression) Type:varType Variables:V1 {: RESULT=new VarDeclarationExpression(varType, V1); RESULT.setLine(varTypeleft); :};

Variables ::= (Variables) VarsList:V1 LastVarDecl:L2 {: RESULT=new Variables(V1, L2); RESULT.setLine(V1left); :};

VarsList ::= (VariablesList) VarsList:V1 MiddleVarDecl:M2 {: RESULT=new VariablesList(V1, M2); RESULT.setLine(V1left); :}
             |
             (NoVarsDeclaration) {: RESULT=new NoVarsDeclaration(); :}
             ;

LastVarDecl ::= (LastVarDeclaration) VarDecl:V1 SEMI {: RESULT=new LastVarDeclaration(V1); RESULT.setLine(V1left); :}
                |
                error SEMI
                {: parser.report_error("Bad variable declaration ", null); :} {: RESULT=new LastVarDeclDerived1(); :}
                ;

MiddleVarDecl ::= (MiddleVarDeclaration) VarDecl:V1 COMMA {: RESULT=new MiddleVarDeclaration(V1); RESULT.setLine(V1left); :}
                   |
                   error COMMA:l
                   {: parser.report_error("Bad variable declaration ", null); :} {: RESULT=new MiddleVarDeclDerived1(); :}
                   ;

VarDecl ::= (VarDeclaration) IDENT:varName ArrOpt:A1 {: RESULT=new VarDeclaration(varName, A1); RESULT.setLine(varNameleft); :};

ArrOpt ::= (ArrayOption) LSQBRACE RSQBRACE {: RESULT=new ArrayOption(); :}
            |
            (NoArrayOption) {: RESULT=new NoArrayOption(); :};

EnumDecl ::= (EnumDeclaration) ENUM IDENT:eName LBRACE EnumList:E1 RBRACE SEMI {: RESULT=new EnumDeclaration(eName, E1); RESULT.setLine(eNameleft); :};

EnumList ::= (EnumMembersList) EnumList:E1 COMMA EnumMember:E2 {: RESULT=new EnumMembersList(E1, E2); RESULT.setLine(E1left); :}
            | (SingleEnumMember) EnumMember:E1 {: RESULT=new SingleEnumMember(E1); RESULT.setLine(E1left); :}
            ;

EnumMember ::= (EnumMember) IDENT:enumMemberName EnumInit:E1 {: RESULT=new EnumMember(enumMemberName, E1); RESULT.setLine(enumMemberNameleft); :};

EnumInit ::= (SingleEnumInit) ASSIGNMENT NUMBER:enumMemberValue {: RESULT=new SingleEnumInit(enumMemberValue); RESULT.setLine(enumMemberValueleft); :}
              |
              (NoEnumInit) {: RESULT=new NoEnumInit(); :}
              ;

RetType ::= (RetVoid) VOID:retVoid {: RESULT=new RetVoid(); :} | (ReturnType) Type:retType {: RESULT=new ReturnType(retType); RESULT.setLine(retTypeleft); :};

FormParams ::= (FormParamsDeclaration) FormParams:F1 COMMA FormPara:F2 {: RESULT=new FormParamsDeclaration(F1, F2); RESULT.setLine(F1left); :}
              | (SingleFormParametarDeclaration) FormPara:F1 {: RESULT=new SingleFormParametarDeclaration(F1); RESULT.setLine(F1left); :}
              | (NoFormParamsDeclaration) {: RESULT=new NoFormParamsDeclaration(); :}
              |
              error
              {: parser.report_error("Bad formal argument  ", null); :} {: RESULT=new FormParamsDerived1(); :}
              ;

FormPara ::= (FormalParams) Type:paramType IDENT:paramName ArrOpt:A1 {: RESULT=new FormalParams(paramType, paramName, A1); RESULT.setLine(paramTypeleft); :};

MethodDeclList ::= (MethodDeclarationList) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarationList(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDecl) {: RESULT=new NoMethodDecl(); :}/* epsilon */
					;

MethodDecl ::= (MethodDecl) RetType:R1 IDENT:methodName LPAREN FormParams:F2 RPAREN OptVar:O3 LBRACE Statements:S4 RBRACE {: RESULT=new MethodDecl(R1, methodName, F2, O3, S4); RESULT.setLine(R1left); :};

Statements ::= (StatementList) Statements:S1 Statement:S2 {: RESULT=new StatementList(S1, S2); RESULT.setLine(S1left); :}
                  |
                  (NoStatementList) {: RESULT=new NoStatementList(); :}
                  ;

Statement ::= (DesignatorStatement) DesignatorStmt:D1 SEMI {: RESULT=new DesignatorStatement(D1); RESULT.setLine(D1left); :}
			  |
			  Designator:D1 AssignOp:A2 error SEMI:l
              {: parser.report_error("Bad assignment statement ", null); :} {: RESULT=new StatementDerived1(D1, A2); RESULT.setLine(D1left); :}
			  |
			  (IfStatement) IF IfConditionForm:I1 Statement:S2 {: RESULT=new IfStatement(I1, S2); RESULT.setLine(I1left); :}
			  |
			  (IfElseStatement) IF IfConditionForm:I1 Statement:S2 ELSE Statement:S3 {: RESULT=new IfElseStatement(I1, S2, S3); RESULT.setLine(I1left); :}
			  |
			  (ForStatement) FOR LPAREN OptDesignatorStatement:O1 SEMI OptCondition:O2 SEMI OptDesignatorStatement:O3 RPAREN Statement:S4 {: RESULT=new ForStatement(O1, O2, O3, S4); RESULT.setLine(O1left); :}
			  |
			  (BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
			  |
			  (ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
			  |
			  (ReadStatement) READ LPAREN Designator:dest RPAREN SEMI {: RESULT=new ReadStatement(dest); RESULT.setLine(destleft); :}
			  |
			  (PrintStatement) PRINT LPAREN  ExpressionToPrint:E1 RPAREN SEMI {: RESULT=new PrintStatement(E1); RESULT.setLine(E1left); :}
			  |
			  (ReturnExpStatement) RETURN Expr:retExp SEMI {: RESULT=new ReturnExpStatement(retExp); RESULT.setLine(retExpleft); :}
			  |
			  (ReturnNopStatement) RETURN SEMI {: RESULT=new ReturnNopStatement(); :}
			  |
			  (StatementBlock) LBRACE Statement:S1 RBRACE {: RESULT=new StatementBlock(S1); RESULT.setLine(S1left); :}
			  ;

OptDesignatorStatement ::= (SingleDesignatorStatement) DesignatorStmt:D1 {: RESULT=new SingleDesignatorStatement(D1); RESULT.setLine(D1left); :}
                           |
                           (NoDesignatorStatement) {: RESULT=new NoDesignatorStatement(); :}
                           ;

IfConditionForm ::= (IfCondition) LPAREN ConditionDecl:C1 RPAREN {: RESULT=new IfCondition(C1); RESULT.setLine(C1left); :}
                    |
                    LPAREN error RPAREN:l
                    {: parser.report_error("Bad condition ", null); :} {: RESULT=new IfConditionFormDerived1(); :}
                    ;

OptCondition::= (Condition) ConditionDecl:C1 {: RESULT=new Condition(C1); RESULT.setLine(C1left); :}
                |
                (NoCondition) {: RESULT=new NoCondition(); :}
                ;

ExpressionToPrint ::= (ExpressionToPrintList) ExpressionToPrint:E1 COMMA NUMBER:value {: RESULT=new ExpressionToPrintList(E1, value); RESULT.setLine(E1left); :}
                      |
                      (SingleExpressionToPrint) Expr:exprToPrint {: RESULT=new SingleExpressionToPrint(exprToPrint); RESULT.setLine(exprToPrintleft); :}
                      ;


DesignatorStmt ::= (DesignatorStatementDef) Designator:dest OptDesignatorStatementExtension:O1 {: RESULT=new DesignatorStatementDef(dest, O1); RESULT.setLine(destleft); :};

OptDesignatorStatementExtension ::= (AssignExtension) AssignOp:A1 Expr:expValue {: RESULT=new AssignExtension(A1, expValue); RESULT.setLine(A1left); :}
                                    |
                                    (ParametarsExtension) LPAREN ActualPars:A1 RPAREN {: RESULT=new ParametarsExtension(A1); RESULT.setLine(A1left); :}
                                    |
                                    (IncExtension) INC {: RESULT=new IncExtension(); :}
                                    |
                                    (DecExtension) DEC {: RESULT=new DecExtension(); :}
                                    |
                                    (NoExtension) {: RESULT=new NoExtension(); :}
                                    ;

ConditionDecl ::= (TermListCondition) ConditionDecl:C1 OR CondTerm:C2 {: RESULT=new TermListCondition(C1, C2); RESULT.setLine(C1left); :}
              |
              (SingleTermCondition) CondTerm:C1 {: RESULT=new SingleTermCondition(C1); RESULT.setLine(C1left); :}
              ;

CondTerm ::= (CondFactListTerm) CondFact:C1 AND CondFact:C2 {: RESULT=new CondFactListTerm(C1, C2); RESULT.setLine(C1left); :}
             |
             (SingleCondFactTerm) CondFact:C1 {: RESULT=new SingleCondFactTerm(C1); RESULT.setLine(C1left); :};

CondFact ::= (ConditionFactor) CondFact:C1 RelOp:R2 Expr:E3 {: RESULT=new ConditionFactor(C1, R2, E3); RESULT.setLine(C1left); :}
           | (SingleCondFact) Expr:E1 {: RESULT=new SingleCondFact(E1); RESULT.setLine(E1left); :}
           ;

Expr ::= (TermListExpr) Expr:E1 Addop:A2 Term:T3 {: RESULT=new TermListExpr(E1, A2, T3); RESULT.setLine(E1left); :}
          |
          (SingleTermExpr) SignTerm:S1 {: RESULT=new SingleTermExpr(S1); RESULT.setLine(S1left); :};

SignTerm ::= (MinusTerm) MINUS Term:T1 {: RESULT=new MinusTerm(T1); RESULT.setLine(T1left); :}
             |
             (NoSignTerm) Term:T1 {: RESULT=new NoSignTerm(T1); RESULT.setLine(T1left); :};

Term ::= (FactorListTerm) Term:T1 MulOp:M2 Factor:F3 {: RESULT=new FactorListTerm(T1, M2, F3); RESULT.setLine(T1left); :}
         |
         (SingleFactorTerm) Factor:F1 {: RESULT=new SingleFactorTerm(F1); RESULT.setLine(F1left); :};

Factor ::= (ParenFactor) LPAREN Expr:E1 RPAREN {: RESULT=new ParenFactor(E1); RESULT.setLine(E1left); :}
		   |
		   (CharFactor) CHARCONST:valueChar {: RESULT=new CharFactor(valueChar); RESULT.setLine(valueCharleft); :}
		   |
		   (BoolFactor) BOOL_CONST:valBool {: RESULT=new BoolFactor(valBool); RESULT.setLine(valBoolleft); :}
		   |
		   (NewTypeFactor) NEW Type:T1 ArrWithExpr:A2 {: RESULT=new NewTypeFactor(T1, A2); RESULT.setLine(T1left); :}
		   |
		   (DesignatorFactor) Designator:d {: RESULT=new DesignatorFactor(d); RESULT.setLine(dleft); :}
		   |
		   (FunCallFactor) Designator:func LPAREN ActualPars:A1 RPAREN {: RESULT=new FunCallFactor(func, A1); RESULT.setLine(funcleft); :}
		   |
		   (NumberFactor) NUMBER:valueNumber {: RESULT=new NumberFactor(valueNumber); RESULT.setLine(valueNumberleft); :}
		   ;

ActualPars ::= (ActualParametarsList) ActualParamList:A1 {: RESULT=new ActualParametarsList(A1); RESULT.setLine(A1left); :}
			   |
			   (NoActualParametarsList) {: RESULT=new NoActualParametarsList(); :}
			   ;

ActualParamList ::= (ParametarsList) ActualParamList:A1 COMMA Expr:E2 {: RESULT=new ParametarsList(A1, E2); RESULT.setLine(A1left); :}
					 |
					 (SingleExpr) Expr:E1 {: RESULT=new SingleExpr(E1); RESULT.setLine(E1left); :}
					 ;

Designator ::= (Designator) IDENT:dest OptDesignatorPart:O1 {: RESULT=new Designator(dest, O1); RESULT.setLine(destleft); :};

OptDesignatorPart ::= (OptionalFieldDesignatorPart) FieldOption:F1 {: RESULT=new OptionalFieldDesignatorPart(F1); RESULT.setLine(F1left); :}
                    | (OptionalArrayDesignatorPart) ArrWithExpr:A1 {: RESULT=new OptionalArrayDesignatorPart(A1); RESULT.setLine(A1left); :}
                    | (NoOptionalPart) {: RESULT=new NoOptionalPart(); :}
                    ;

FieldOption ::= (Field) DOT IDENT:desField {: RESULT=new Field(desField); RESULT.setLine(desFieldleft); :};

ArrWithExpr ::= (ArrayWithExpr) LSQBRACE Expr:arrExp RSQBRACE {: RESULT=new ArrayWithExpr(arrExp); RESULT.setLine(arrExpleft); :};

AssignOp ::= (Assignment) ASSIGNMENT {: RESULT=new Assignment(); :};

RelOp ::= (Equal) EQUAL {: RESULT=new Equal(); :}
        | (Unequal) UNEQUAL {: RESULT=new Unequal(); :}
        | (Greater) GREATER {: RESULT=new Greater(); :}
        | (GreaterEqual) GREATER_EQUAL {: RESULT=new GreaterEqual(); :}
        | (Smaller)SMALLER {: RESULT=new Smaller(); :}
        | (SmallerEqual) SMALLER_EQUAL {: RESULT=new SmallerEqual(); :};

Addop ::= (PlusOp) PLUS {: RESULT=new PlusOp(); :} | (MinusOp) MINUS {: RESULT=new MinusOp(); :};

MulOp ::= (MulOp) MUL {: RESULT=new MulOp(); :} | (DivOp) DIV {: RESULT=new DivOp(); :} | (ModOp) MOD {: RESULT=new ModOp(); :};
